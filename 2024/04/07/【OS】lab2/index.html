<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="lab2实验笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="【OS】lab2">
<meta property="og:url" content="http://example.com/2024/04/07/%E3%80%90OS%E3%80%91lab2/index.html">
<meta property="og:site_name" content="碳罐堆积处">
<meta property="og:description" content="lab2实验笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-07T09:48:12.000Z">
<meta property="article:modified_time" content="2024-04-22T14:26:21.550Z">
<meta property="article:author" content="Carbon">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2024/04/07/%E3%80%90OS%E3%80%91lab2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/04/07/%E3%80%90OS%E3%80%91lab2/","path":"2024/04/07/【OS】lab2/","title":"【OS】lab2"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【OS】lab2 | 碳罐堆积处</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">碳罐堆积处</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KADDR%EF%BC%8CPADDR"><span class="nav-number">1.1.</span> <span class="nav-text">KADDR，PADDR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPN%EF%BC%8CVPN"><span class="nav-number">1.2.</span> <span class="nav-text">PPN，VPN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PDX%EF%BC%8CPTX"><span class="nav-number">1.3.</span> <span class="nav-text">PDX，PTX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pde%EF%BC%8CPte"><span class="nav-number">1.4.</span> <span class="nav-text">Pde，Pte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PTE-ADDR-pte"><span class="nav-number">1.5.</span> <span class="nav-text">PTE_ADDR(pte)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pa2page%EF%BC%8Cpage2pa"><span class="nav-number">1.6.</span> <span class="nav-text">pa2page，page2pa</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#npage"><span class="nav-number">1.7.</span> <span class="nav-text">npage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page"><span class="nav-number">2.</span> <span class="nav-text">Page</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%8F"><span class="nav-number">2.1.</span> <span class="nav-text">链表宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mips-vm-init"><span class="nav-number">2.2.1.</span> <span class="nav-text">mips_vm_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page-init"><span class="nav-number">2.2.2.</span> <span class="nav-text">page_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page-alloc"><span class="nav-number">2.2.3.</span> <span class="nav-text">page_alloc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pgdir-walk"><span class="nav-number">2.2.4.</span> <span class="nav-text">pgdir_walk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page-lookup"><span class="nav-number">2.2.5.</span> <span class="nav-text">page_lookup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page-insert"><span class="nav-number">2.2.6.</span> <span class="nav-text">page_insert</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%98%A0%E5%B0%84"><span class="nav-number">3.</span> <span class="nav-text">自映射</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Carbon</p>
  <div class="site-description" itemprop="description">还没想出高级的博客名；出现问题欢迎交流指正喵。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E3%80%90OS%E3%80%91lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carbon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="碳罐堆积处">
      <meta itemprop="description" content="还没想出高级的博客名；出现问题欢迎交流指正喵。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【OS】lab2 | 碳罐堆积处">
      <meta itemprop="description" content="lab2实验笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【OS】lab2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-07 17:48:12" itemprop="dateCreated datePublished" datetime="2024-04-07T17:48:12+08:00">2024-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-22 22:26:21" itemprop="dateModified" datetime="2024-04-22T22:26:21+08:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">lab2实验笔记</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>读指导书的时候觉得写的什么东西看不懂一点，然而看完了感觉助教也是尽力了……本来想按照更加自然的逻辑顺序整理一下，还是挺困难，写的时候也是这里补一点那里改一点。本文先从使用的角度介绍一些比较关键的宏或者类型，然后是实验中的<code>Page</code>结构体和对应使用的链表。到这为止都是为了<strong>读懂</strong>代码而写，在本人上机前只折腾到这里，如果是OS天生圣体不用看这些絮絮叨叨颠来倒去的东西。之后罗列了链表宏和函数，以及补充介绍了自映射机制。板块间没有很强的联系，但知识又确实是穿插杂糅的，嗯……不需要从头到尾按顺序阅读，跳着跳着看吧。</p>
</blockquote>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="KADDR，PADDR"><a href="#KADDR，PADDR" class="headerlink" title="KADDR，PADDR"></a>KADDR，PADDR</h3><p>具体实现姑且忽略掉，<code>KADDR(pa)</code>是把物理地址转为虚拟地址，而<code>PADDR(kva)</code>是把虚拟地址转为物理地址。这里要求虚拟地址都是<strong>内核态</strong>虚拟地址。本次页表会用到。</p>
<h3 id="PPN，VPN"><a href="#PPN，VPN" class="headerlink" title="PPN，VPN"></a>PPN，VPN</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Page number field of an address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(pa) (((u_long)(pa)) &gt;&gt; PGSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN(va) (((u_long)(va)) &gt;&gt; PGSHIFT)</span></span><br></pre></td></tr></table></figure>
<h3 id="PDX，PTX"><a href="#PDX，PTX" class="headerlink" title="PDX，PTX"></a>PDX，PTX</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDSHIFT 22 <span class="comment">// log2(PDMAP)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; PDSHIFT) &amp; 0x03FF)  <span class="comment">//Page Directory indeX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; PGSHIFT) &amp; 0x03FF)  <span class="comment">//Page Table indeX</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Pde，Pte"><a href="#Pde，Pte" class="headerlink" title="Pde，Pte"></a>Pde，Pte</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u_long Pde; </span><br><span class="line"><span class="keyword">typedef</span> u_long Pte;</span><br></pre></td></tr></table></figure>
<p>分别是一级页表项和二级页表项，一般用是建立指向某页表项的指针<code>Pde *pde</code>，解指针得到表项内容。<code>Pde *pgdir</code>指向第一个页目录项，也是页目录的地址，要得到第n项就<code>Pde *pde = pgdir + n</code>。注意页表项中存的都是<strong>物理页号和权限位</strong>。<code>*pde</code>取得的是一级页表项的值，如果需要求得对应二级页表物理地址就<code>PTE_ADDR(*pde)</code>，如果是求虚拟地址需要再套一层<code>KADDR()</code>。</p>
<h3 id="PTE-ADDR-pte"><a href="#PTE-ADDR-pte" class="headerlink" title="PTE_ADDR(pte)"></a>PTE_ADDR(pte)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) (((u_long)(pte)) &amp; ~0xFFF)</span></span><br></pre></td></tr></table></figure>
<p>该宏清空后12位权限位。二级页表是4KB对齐，故虽然说高20位存的是物理页号但清空后12位后直接得到物理地址（PPN宏函数也是这个道理）。</p>
<p><code>Pte</code>用法类似，比如在<code>page_lookup()</code>中有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pte *pte;</span><br><span class="line">...</span><br><span class="line">pp = pa2page(*pte);</span><br></pre></td></tr></table></figure>
<h3 id="pa2page，page2pa"><a href="#pa2page，page2pa" class="headerlink" title="pa2page，page2pa"></a>pa2page，page2pa</h3><p>里面<code>pa2page</code>实现为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> Page *<span class="title function_">pa2page</span><span class="params">(u_long pa)</span> {</span><br><span class="line">	<span class="keyword">if</span> (PPN(pa) &gt;= npage) {</span><br><span class="line">		panic(<span class="string">"pa2page called with invalid pa: %x"</span>, pa);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> &amp;pages[PPN(pa)];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>*pte</code>为页表项内容（也就是物理地址），通过<code>PPN</code>转为物理页号后通过<code>pages</code>获得对应。</p>
<p><code>pa2page</code>和<code>page2pa</code>都是Page与其对应物理页面地址的转换。</p>
<h3 id="npage"><a href="#npage" class="headerlink" title="npage"></a>npage</h3><p>注意类型为<code>u_long</code>。</p>
<p>npage个<code>Page</code>和npage个物理页面一一对应。<code>Page</code>起始地址为<code>pages</code>，<code>pages[i]</code>获得对应物理页面。</p>
<h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><p><code>queue.h</code></p>
<p>HEAD是链表头结点指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name, type)                                                                      \</span></span><br><span class="line"><span class="meta">	struct name {                                                                              \</span></span><br><span class="line"><span class="meta">		struct type *lh_first; <span class="comment">/* first element */</span>                                         \</span></span><br><span class="line"><span class="meta">	}</span></span><br></pre></td></tr></table></figure>
<p>ENTRY是结点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#define LIST_ENTRY(<span class="keyword">type</span>)                                                                           \</span><br><span class="line">	<span class="keyword">struct</span> {                                                                                   \</span><br><span class="line">		<span class="keyword">struct</span> <span class="keyword">type</span> *le_next;  <span class="comment">/* next element */</span>                                          \</span><br><span class="line">		<span class="keyword">struct</span> <span class="keyword">type</span> **le_prev; <span class="comment">/* address of previous next element */</span>                      \</span><br><span class="line">	}</span><br></pre></td></tr></table></figure>
<p><code>pmap.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(Page_list, Page);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> {</span></span><br><span class="line">	Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ref is the count of pointers (usually in page table entries)</span></span><br><span class="line">	<span class="comment">// to this page.  This only holds for pages allocated using</span></span><br><span class="line">	<span class="comment">// page_alloc.  Pages allocated at boot time using pmap.c's "alloc"</span></span><br><span class="line">	<span class="comment">// do not have valid reference count fields.</span></span><br><span class="line"></span><br><span class="line">	u_short pp_ref;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> <span class="title">page_free_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>加上extern是为了引用外部的变量（在<code>kern/pmap.c</code>初始化<code>page_free_list</code>）</p>
<p>完整展开就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> {</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span>  </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">le_next</span>;</span> </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">type</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        } pp_link;</span><br><span class="line">    	u_short pp_ref;</span><br><span class="line">    } *lh_first;                      </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>顺便提一嘴链表宏，一般是传递指针进行操作，更准确的来说更关注该页面的虚拟地址而不是页面内容。诸如在<code>page_alloc()</code>中有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">...</span><br><span class="line">pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line">LIST_REMOVE(pp, pp_link);</span><br></pre></td></tr></table></figure>
<p>取得的<code>pp</code>是Page结构体指针，也就是该虚拟页面的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> {</span><br><span class="line">	<span class="keyword">return</span> page2ppn(pp) &lt;&lt; PGSHIFT;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这种虚拟页面获取对应物理地址也是通过传递页面指针。</p>
<h3 id="链表宏"><a href="#链表宏" class="headerlink" title="链表宏"></a>链表宏</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="mips-vm-init"><a href="#mips-vm-init" class="headerlink" title="mips_vm_init"></a>mips_vm_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment">    Set up two-level page table.</span></span><br><span class="line"><span class="comment">   Hint:</span></span><br><span class="line"><span class="comment">    You can get more details about `UPAGES` and `UENVS` in include/mmu.h. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">()</span> {</span><br><span class="line">	<span class="comment">/* Allocate proper size of physical memory for global array `pages`,</span></span><br><span class="line"><span class="comment">	 * for physical memory management. Then, map virtual address `UPAGES` to</span></span><br><span class="line"><span class="comment">	 * physical address `pages` allocated before. For consideration of alignment,</span></span><br><span class="line"><span class="comment">	 * you should round up the memory size before map. */</span></span><br><span class="line">	pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), PAGE_SIZE, <span class="number">1</span>);</span><br><span class="line">	printk(<span class="string">"to memory %x for struct Pages.\n"</span>, freemem);</span><br><span class="line">	printk(<span class="string">"pmap.c:\t mips vm init success\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="page-init"><a href="#page-init" class="headerlink" title="page_init"></a>page_init</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Initialize page structure and memory free list. The 'pages' array has one 'struct Page' entry</span></span><br><span class="line"><span class="comment"> * per physical page. Pages are reference counted, and free pages are kept on a linked list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint: Use 'LIST_INSERT_HEAD' to insert free pages to 'page_free_list'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">	<span class="comment">/* Step 1: Initialize page_free_list. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use macro `LIST_INIT` defined in include/queue.h. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (1/4) */</span></span><br><span class="line">	LIST_INIT(&amp;page_free_list);</span><br><span class="line">	<span class="comment">/* Step 2: Align `freemem` up to multiple of PAGE_SIZE. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (2/4) */</span></span><br><span class="line">	freemem = ROUND((freemem), PAGE_SIZE);</span><br><span class="line">	<span class="comment">/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (3/4) */</span></span><br><span class="line">	u_long u = PPN(PADDR(freemem));</span><br><span class="line">	<span class="keyword">for</span> (u_long i = <span class="number">0</span>; i &lt; u; i ++) {</span><br><span class="line">		pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* Step 4: Mark the other memory as free. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (4/4) */</span></span><br><span class="line">	<span class="keyword">for</span> (u_long i = u; i &lt; npage; i++) {</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		LIST_INSERT_HEAD(&amp;page_free_list, pages + i, pp_link);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc"></a>page_alloc</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Allocate a physical page from free memory, and fill this page with zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   If failed to allocate a new page (out of memory, there's no free page), return -E_NO_MEM.</span></span><br><span class="line"><span class="comment"> *   Otherwise, set the address of the allocated 'Page' to *pp, and return 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note:</span></span><br><span class="line"><span class="comment"> *   This does NOT increase the reference count 'pp_ref' of the page - the caller must do these if</span></span><br><span class="line"><span class="comment"> *   necessary (either explicitly or via page_insert).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint: Use LIST_FIRST and LIST_REMOVE defined in include/queue.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **new)</span> {</span><br><span class="line">	<span class="comment">/* Step 1: Get a page from free memory. If fails, return the error code.*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 2.4: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	}</span><br><span class="line">	pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line">	LIST_REMOVE(pp, pp_link);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Initialize this page with zero.</span></span><br><span class="line"><span class="comment">	 * Hint: use `memset`. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.4: Your code here. (2/2) */</span></span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">	*new = pp;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk"></a>pgdir_walk</h4><p><code>int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)</code></p>
<p>将一级页表基地址 pgdir 对应的两级页表结构中 va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上。说得这么抽象，简单理解就是根据va查找到对应二级页表中的页表项，将ppte的值设为这个页表项的地址。</p>
<h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup"></a>page_lookup</h4><p>返回一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 映射的物理页面的页控制块，同时将 ppte 指向的空间设为对应的二级页表项地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Overview:</span></span><br><span class="line"><span class="comment">    Look up the Page that virtual address `va` map to.</span></span><br><span class="line"><span class="comment">  Post-Condition:</span></span><br><span class="line"><span class="comment">    Return a pointer to corresponding Page, and store it's page table entry to *ppte.</span></span><br><span class="line"><span class="comment">    If `va` doesn't mapped to any Page, return NULL.*/</span></span><br><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span> {</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	Pte *pte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the page table entry. */</span></span><br><span class="line">	pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hint: Check if the page table entry doesn't exist or is not valid. */</span></span><br><span class="line">	<span class="keyword">if</span> (pte == <span class="literal">NULL</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Get the corresponding Page struct. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use function `pa2page`, defined in include/pmap.h . */</span></span><br><span class="line">	pp = pa2page(*pte);</span><br><span class="line">	<span class="keyword">if</span> (ppte) {</span><br><span class="line">		*ppte = pte;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert"></a>page_insert</h4><p><code>int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm)</code></p>
<p>将一级页表基地址pgdir对应的二级页表结构中虚拟地址va映射到页控制块pp对应的物理地址</p>
<p>简单理解就是填写页表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Map the physical page 'pp' at virtual address 'va'. The permission (the low 12 bits) of the</span></span><br><span class="line"><span class="comment"> *   page table entry should be set to 'perm | PTE_C_CACHEABLE | PTE_V'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 on success</span></span><br><span class="line"><span class="comment"> *   Return -E_NO_MEM, if page table couldn't be allocated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint:</span></span><br><span class="line"><span class="comment"> *   If there is already a page mapped at `va`, call page_remove() to release this mapping.</span></span><br><span class="line"><span class="comment"> *   The `pp_ref` should be incremented if the insertion succeeds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va, u_int perm)</span> {</span><br><span class="line">	Pte *pte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get corresponding page table entry. */</span></span><br><span class="line">	pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_V)) {</span><br><span class="line">		<span class="keyword">if</span> (pa2page(*pte) != pp) {</span><br><span class="line">			page_remove(pgdir, asid, va);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			tlb_invalidate(asid, va);</span><br><span class="line">			*pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Flush TLB with 'tlb_invalidate'. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.7: Your code here. (1/3) */</span></span><br><span class="line">	tlb_invalidate(asid, va);</span><br><span class="line">	<span class="comment">/* Step 3: Re-get or create the page table entry. */</span></span><br><span class="line">	<span class="comment">/* If failed to create, return the error. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.7: Your code here. (2/3) */</span></span><br><span class="line">	<span class="keyword">if</span> (pgdir_walk(pgdir, va, <span class="number">1</span>, &amp;pte) != <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* Step 4: Insert the page to the page table entry with 'perm | PTE_C_CACHEABLE | PTE_V'</span></span><br><span class="line"><span class="comment">	 * and increase its 'pp_ref'. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.7: Your code here. (3/3) */</span></span><br><span class="line">	*pte = page2pa(pp) | perm | PTE_C_CACHEABLE | PTE_V;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="自映射"><a href="#自映射" class="headerlink" title="自映射"></a>自映射</h2><p>我们的需求是填写和修改页表，这就需要读写页表所在的内存，此处的地址使用<strong>虚拟地址</strong>（页目录自映射也全都是虚拟地址空间内的映射而与物理地址无关）。于是我们开始探索虚拟地址空间。已知页目录大小为4KB，一共有1024个页表项，而一页的大小也是4KB，所以页表总共大小为4MB。然而，在虚拟内存空间中只能看到页表的4MB而没有页目录的4KB，也就说明页目录没有分配单独的存储空间。那么页目录到底在哪呢。答案是页目录和页表大小相等，所以完美地混在4MB的页表中。</p>
<p>再次强调，在理解页目录自映射的时候不要关注表项具体内容或者将页表想象成离散的东西，这里关注的是虚拟空间，二级页表是<strong>连续</strong>存储的，页面号是从低地址到高地址递增的。整个虚拟空间是4GB，将其划分为1K个4MB，此处4MB理解为一个二级页表所管辖的区域（1K个4KB）。又知二级页表总共占4MB大小，所以会有一个页表管理这4MB。<strong>4MB在4GB中的位置也是该页表在页目录中的位置</strong>（这里的位置指索引或者偏移量）。哎，4MB中的构成也是1K个4KB页，为什么不让页目录这个4KB在4MB中的位置也是上述的位置呢？这就是自映射干的事情。</p>
<p>给出页表基址，可以根据偏移量（以页面大小为单位）找到页目录表基址，再偏移一下（页内偏移）找到自映射目录表项。</p>
<ul>
<li><strong>页表基址</strong>：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="6.237ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 2756.6 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="msub" transform="translate(751,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="TeXAtom" transform="translate(617,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mi" transform="translate(429,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(958,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(1427,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g></g></g></g></g></svg></mjx-container>该基址需要4M对齐。</li>
<li><strong>页目录表基址</strong>：该基址4K对齐。</li>
<li><strong>自映射目录表项</strong>：存页目录表的物理页框号和权限位，该表项地址就是题目常问的一级页表中映射自己的表项的虚拟地址</li>
</ul>
<p>由二级页表自映射可以推三级页表甚至更高级，如往年题：</p>
<blockquote>
<p>64位操作系统采用三级页表进行虚拟内存管理，每个页表大小为4KB，页表项需要字对齐，其余条件与二级页表管理32位操作系统相同。请问64位中最少用多少位表示虚拟地址。</p>
</blockquote>
<p>由页面大小可得到页内偏移应该为12位，最底层页表项是物理地址，一共有4KB/8B个页表项，所以是9位，所以虚拟地址是3*9+12=39位</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Carbon
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2024/04/07/%E3%80%90OS%E3%80%91lab2/" title="【OS】lab2">http://example.com/2024/04/07/【OS】lab2/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/24/%E3%80%90OS%E3%80%91lab1/" rel="prev" title="【OS】lab1">
                  <i class="fa fa-angle-left"></i> 【OS】lab1
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/15/%E3%80%90OS%E3%80%91memory/" rel="next" title="【OS】memory">
                  【OS】memory <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Carbon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
