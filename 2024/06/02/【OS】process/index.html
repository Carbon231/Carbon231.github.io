<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="进程相关理论总结。">
<meta property="og:type" content="article">
<meta property="og:title" content="【OS】process">
<meta property="og:url" content="http://example.com/2024/06/02/%E3%80%90OS%E3%80%91process/index.html">
<meta property="og:site_name" content="碳罐堆积处">
<meta property="og:description" content="进程相关理论总结。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603194616552.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603201306208.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603201455796.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603213417250.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603214503365.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603220859443.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603223025725.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603223131163.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240604102052946.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603203722724.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603203735890.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603204656713.png">
<meta property="og:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240604120054557.png">
<meta property="article:published_time" content="2024-06-02T11:43:17.000Z">
<meta property="article:modified_time" content="2024-06-08T06:40:20.091Z">
<meta property="article:author" content="Carbon">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E3%80%90OS%E3%80%91process/image-20240603194616552.png">


<link rel="canonical" href="http://example.com/2024/06/02/%E3%80%90OS%E3%80%91process/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/06/02/%E3%80%90OS%E3%80%91process/","path":"2024/06/02/【OS】process/","title":"【OS】process"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【OS】process | 碳罐堆积处</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">碳罐堆积处</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.2.</span> <span class="nav-text">进程控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">实现方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">3.</span> <span class="nav-text">同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="nav-number">3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E4%BA%92%E6%96%A5"><span class="nav-number">3.2.</span> <span class="nav-text">基于忙等待的互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dekker"><span class="nav-number">3.2.1.</span> <span class="nav-text">Dekker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Peterson"><span class="nav-number">3.2.2.</span> <span class="nav-text">Peterson</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bakery"><span class="nav-number">3.2.3.</span> <span class="nav-text">Bakery</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD"><span class="nav-number">3.2.4.</span> <span class="nav-text">中断屏蔽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#test-and-set"><span class="nav-number">3.2.5.</span> <span class="nav-text">test and set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="nav-number">3.2.6.</span> <span class="nav-text">优先级反转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">基于信号量的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">3.4.</span> <span class="nav-text">基于管程的同步与互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">3.5.</span> <span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">3.6.</span> <span class="nav-text">经典进程同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">3.6.1.</span> <span class="nav-text">生产者-消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85"><span class="nav-number">3.6.2.</span> <span class="nav-text">读者-写者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90"><span class="nav-number">3.6.3.</span> <span class="nav-text">哲学家进餐</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">4.2.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">4.2.2.</span> <span class="nav-text">死锁避免</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="nav-number">4.2.3.</span> <span class="nav-text">检测死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="nav-number">4.2.4.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="nav-number">5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">批处理系统调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">交互式系统调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">实时系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%A1%A8%E8%B0%83%E5%BA%A6"><span class="nav-number">5.4.1.</span> <span class="nav-text">静态表调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%80%9F%E7%8E%87%E8%B0%83%E5%BA%A6RMS"><span class="nav-number">5.4.2.</span> <span class="nav-text">单调速率调度RMS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%9C%9F%E4%BC%98%E5%85%88EDF"><span class="nav-number">5.4.3.</span> <span class="nav-text">最早截止期优先EDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95LLF"><span class="nav-number">5.4.4.</span> <span class="nav-text">最低松弛度优先算法LLF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">5.5.</span> <span class="nav-text">多处理机调度</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Carbon</p>
  <div class="site-description" itemprop="description">还没想出高级的博客名；出现问题欢迎交流指正喵。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/06/02/%E3%80%90OS%E3%80%91process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carbon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="碳罐堆积处">
      <meta itemprop="description" content="还没想出高级的博客名；出现问题欢迎交流指正喵。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="【OS】process | 碳罐堆积处">
      <meta itemprop="description" content="进程相关理论总结。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【OS】process
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-02 19:43:17" itemprop="dateCreated datePublished" datetime="2024-06-02T19:43:17+08:00">2024-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-08 14:40:20" itemprop="dateModified" datetime="2024-06-08T14:40:20+08:00">2024-06-08</time>
    </span>

  
</div>

            <div class="post-description">进程相关理论总结。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>并发concurrent：无论是否在同一处理机，起点终点相同</p>
</li>
<li><p>并行parallel：同时运行在不同处理机上，起点终点相同</p>
</li>
<li>程序并发执行特点是间断、非封闭、不可再现</li>
<li>不可再现是因为发生竞争。竞争条件是多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关</li>
<li>Bernstein条件：不会发生竞争的条件。一个进程写的时候另一个不能读，两个进程不能同时写。这是也是判断程序并发执行结果是否可再现的充分条件。</li>
<li>进程特征：并发（间断性），共享（互相制约，非封闭），不确定性（不可再现）</li>
</ol>
<p><strong>进程与程序的区别</strong></p>
<ul>
<li>进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件，静态和可以复制。</li>
<li>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</li>
<li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块(即进程状态信息)。</li>
<li>进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</li>
</ul>
<p><strong>进程实体</strong></p>
<ul>
<li>PCB</li>
<li>共享正文段：全局赋值变量、常量</li>
<li>数据堆段：<code>malloc()</code>动态分配的变量</li>
<li>数据栈段：函数调用、未赋值的局部变量</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>原语</strong></p>
<ul>
<li>必须在管态（内核态）下执行，且常驻内存</li>
<li>不可中断</li>
<li>进程创建（fork, exec）撤销（kill）都是原语</li>
</ul>
<p><strong>创建</strong></p>
<ul>
<li>提交一个批处理作业</li>
<li>用户登录</li>
<li>OS创建</li>
<li>已有的进程创建<ul>
<li>Fork()：一次执行两次返回（返回先后不确定）。子进程返回值为0，父进程返回值为新建子进程的PID。如果出现错误则返回负值。</li>
</ul>
</li>
</ul>
<p><strong>撤销</strong></p>
<ul>
<li>用户退出登录</li>
<li>进程执行终止服务请求</li>
<li>出错</li>
<li>正常结束</li>
<li>给定时限到</li>
</ul>
<p><strong>状态转换</strong></p>
<p><img src="/images/【OS】process/image-20240603194616552.png" alt="image-20240603194616552" style="zoom:50%;"></p>
<ul>
<li>就绪-&gt;执行：时间片到</li>
<li>运行-&gt;就绪：时间片用完；高优先级进程就绪而导致当前进程被中断</li>
<li>运行-&gt;阻塞：所需资源或条件必须等待；初始化I/O并等待结果；等待其他进程提供输入IPC</li>
<li>阻塞-&gt;就绪：等待事情发生</li>
</ul>
<p><strong>进程控制块</strong>PCB</p>
<ul>
<li>进程标志符</li>
<li>程序和数据地址</li>
<li>当前状态<ul>
<li>OS会把相同状态的进程组成一个队列</li>
</ul>
</li>
<li>现场保护</li>
<li>同步与同步机制<ul>
<li>用于实现进程间互斥同步和通信的信号量等</li>
</ul>
</li>
<li>优先级</li>
<li>资源清单<ul>
<li>除CPU外的资源记录，如I/O设备、打开的文件列表等</li>
</ul>
</li>
<li>链接字<ul>
<li>该进程所在调度队列下一个进程的首地址</li>
</ul>
</li>
<li>其他信息</li>
</ul>
<p><strong>PCB组织方式</strong></p>
<ul>
<li>线性表（可能有多个指针，但都直接指向PCB）</li>
<li>索引（在线性表的基础上建立索引，如有就绪表指针指向就绪索引表，进而找到对应的PCB）</li>
<li>链接（按照进程状态组成队列）</li>
</ul>
<p><strong>进程上下文切换和陷入内核</strong></p>
<ul>
<li><p>上下文切换由调度器执行，保存进程执行断点，切换内存映射</p>
</li>
<li><p>陷入内核（模式切换）是CPU状态改变，由中断、异常、Trap（系统调用）引起，需要保存执行现场（寄存器堆栈等）。切换代价比上下文切换小。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ol>
<li>线程是进程中的可执行单位，并发粒度更细，且可以共享资源。</li>
<li>进程是<strong>资源分配</strong>的单位，线程是<strong>CPU调度</strong>的单位（这个说法有点奇怪但标红了还是记一下）</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>用户级线程</strong>ULT</p>
<ul>
<li>通过library模拟，不需要或仅需要少数kernel支持</li>
<li>上下文切换快，因为不需要更新页表，线程切换和内核无关</li>
<li>现成调度由应用决定，更容易优化</li>
<li>可执行在任何操作系统上</li>
<li>OS内核不可感知</li>
<li>不足在于阻塞一个会所有相关线程，且内核只能将处理器分配给进程，无法实现一个进程中多线程并行执行</li>
</ul>
<p><strong>内核级线程</strong>KLT</p>
<ul>
<li>kernel有好几个分身</li>
<li>内核可以在多个处理器上调度一个进程的多个线程实行同步并行执行</li>
<li>阻塞也发生在线程级别</li>
<li>内核的一些处理也可以通过多线程实现</li>
<li>不足在于一个进程中线程切换需要内核参与，进而涉及到模式切换而降低效率</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行</li>
<li>在有内核级线程的系统内，CPU调度则以线程为单位,由OS的线程调度程序负责线程的调度。</li>
<li>用户级线程的程序实体是运行在用户态下的程序，而内核级线程的程序实体则是可以运行在任何状态下的程序。</li>
</ul>
<p><strong>混合实现</strong></p>
<ul>
<li>线程在用户空间创建和管理</li>
<li>需要实现从用户空间线程到内核空间线程的映射</li>
</ul>
<p><img src="/images/【OS】process/image-20240603201306208.png" alt="image-20240603201306208" style="zoom: 50%;"></p>
<p><img src="/images/【OS】process/image-20240603201455796.png" alt="image-20240603201455796"></p>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>临界资源：一次仅允许一个进程访问的资源。</p>
</li>
<li><p>临界区：每个进程中访问临界资源的那段代码称为临界区。</p>
</li>
<li><p>互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。互斥无法限制访问者对资源的访问顺序，即<strong>访问是无序访问</strong>。</p>
</li>
<li><p>同步：是指在互斥的基础上，通过其它机制实现访问者对资源的<strong>有序访问</strong>。在大多数情况下，同步已经实现了互斥，特别是所有对资源的写入的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
</li>
</ul>
<p>机制上需要满足</p>
<ul>
<li>空闲让进：临界资源处于空闲状态，允许进程进入临界区。临界区内仅有一个进程运行。</li>
<li>忙则等待：临界区有正在执行的进程，所有其他进程则不可以进入临界区。</li>
<li>有限等待：对要求访问临界区的进程，应保证在有限时间内进入自己的临界区，避免死等。</li>
<li>让权等待：当进程(长时间)不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li>
</ul>
<h3 id="基于忙等待的互斥"><a href="#基于忙等待的互斥" class="headerlink" title="基于忙等待的互斥"></a>基于忙等待的互斥</h3><p><strong>软件层面</strong></p>
<ul>
<li>如果是检查，则需要注意检查-进入间隙切换</li>
<li>对于标记占有，严格限制进入顺序的设计也被认为不好</li>
<li>标记占有，在进入前检查对方是否进入，则可能导致都进不去</li>
<li>凡有让权就要小心同时进入</li>
</ul>
<h4 id="Dekker"><a href="#Dekker" class="headerlink" title="Dekker"></a>Dekker</h4><p>P：我只关注对方想不想进入</p>
<ol>
<li>当我想进入，先标记一下（<code>pturn=true</code>），再看对方想不想</li>
<li>如果对方想，则检查一下是不是我的回合（<code>turn=0</code>）。如果是，我等到（<code>while(qturn)</code>）对方不想进去再进去。如果不是，则我自愿放弃，等（<code>while(turn==1);</code>）到重新是我的回合再说我想进。</li>
<li>我用完了，回合让给别人（唯一更改turn的地方），我不想进</li>
</ol>
<p><img src="/images/【OS】process/image-20240603213417250.png" alt="image-20240603213417250" style="zoom:50%;"></p>
<h4 id="Peterson"><a href="#Peterson" class="headerlink" title="Peterson"></a>Peterson</h4><ol>
<li>我想进去。</li>
<li>但我不要这个回合（唯一更改turn的地方）</li>
<li>如果别人也不想进去，那我就直接进去了。如果别人要，但是我的回合，那我就进去吧。如果别人要且是别人的回合，那我就再等等（<code>while(turn==other &amp;&amp; interested[other]==true);</code>）。</li>
<li>我用完了，我不想进去。</li>
</ol>
<p><img src="/images/【OS】process/image-20240603214503365.png" alt="image-20240603214503365" style="zoom:50%;"></p>
<h4 id="Bakery"><a href="#Bakery" class="headerlink" title="Bakery"></a>Bakery</h4><ol>
<li>取号进去，号码总是单调不减的，号码最小的进程先进</li>
<li>如果号码相同，则进程号小的先进</li>
</ol>
<p><img src="/images/【OS】process/image-20240603220859443.png" alt="image-20240603220859443" style="zoom:50%;"></p>
<hr>
<p><strong>硬件层面</strong></p>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><ul>
<li>进入临界区后关中断</li>
<li>简单</li>
<li>不适合多CPU系统</li>
<li>会带来性能损失以及使用危险</li>
</ul>
<h4 id="test-and-set"><a href="#test-and-set" class="headerlink" title="test and set"></a>test and set</h4><p>TS是不可中断的基本原语，会把1写到某个内存位置并且返回旧值。如果一个进程正在执行TS指令，在它执行完成前，其它的进程不可以执行TS指令。</p>
<p>应用举例：<strong>自旋锁</strong>Spinlocks</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire(lock) {</span><br><span class="line">   <span class="keyword">while</span>(test_and_set(lock)==<span class="number">1</span>); </span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果lock的值为0（表示锁当前未被占用），test_and_set会返回0（旧值），并将lock设置为1（表示现在锁被该线程占用）。然后，while循环结束，线程可以继续执行临界区（critical section）的代码。</span></span><br><span class="line"><span class="comment">//如果lock的值为1（表示锁当前被其他线程占用），test_and_set会返回1（旧值），并尝试将lock设置为1（但因为它已经是1了，所以实际上这个设置操作没有效果）。然后，while循环继续执行，线程进入忙等待（busy-waiting）状态，直到lock变为0。</span></span><br><span class="line">release(lock) {</span><br><span class="line">    lock=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>优先级反转发生是由于<strong>低优先级进程运行在临界区时由于高优先级进程就绪而被切换</strong>。如果高优先级进程使用<strong>忙等</strong>的策略尝试进入临界区，就会一直忙等，使得低优先级进程没有机会离开临界区。如果使用用户级线程，低优先级线程不会被高优先级线程抢占(进入临界区一般需要系统调用，其他线程也同时会被阻塞),因为抢占发生在进程级别。但是对于内核级线程的实现，这个是可能发生的。</p>
<h3 id="基于信号量的方法"><a href="#基于信号量的方法" class="headerlink" title="基于信号量的方法"></a>基于信号量的方法</h3><p>信号量：一个确定的二元组(s,q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。</p>
<p><img src="/images/【OS】process/image-20240603223025725.png" alt="image-20240603223025725" style="zoom: 50%;"></p>
<p><img src="/images/【OS】process/image-20240603223131163.png" alt="image-20240603223131163" style="zoom: 67%;"></p>
<p><code>compare-and-swap (CAS)</code>也是一条原子指令。它将存储位置的内容与给定值进行比较，并且只有它们相同时，才将该存储位置的内容修改为新的给定值。</p>
<p><strong>信号量的应用</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>应用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥</td>
<td>信号量初始为1。进程进入临界区前P，出来后V。</td>
</tr>
<tr>
<td>有限并发</td>
<td>信号量初始值设为可共享资源数。</td>
</tr>
<tr>
<td>进程同步</td>
<td>进程Pi需要执行ai操作得等Pj执行完aj后。实现如下：Pi执行ai前P一下，Pj执行aj后V一下。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>屏障</strong>Barriers/Rendezvous</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">s<span class="number">0</span> = Semaphore<span class="comment">(0)</span>;</span><br><span class="line">s<span class="number">1</span> = Semaphore<span class="comment">(0)</span>;</span><br><span class="line"></span><br><span class="line">P<span class="number">0</span>:</span><br><span class="line">V<span class="comment">(s0)</span>;</span><br><span class="line">P<span class="comment">(s1)</span>;</span><br><span class="line"></span><br><span class="line">P<span class="number">1</span>:</span><br><span class="line">V<span class="comment">(s1)</span>;</span><br><span class="line">P<span class="comment">(s0)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n=nuber of thread;</span><br><span class="line">count=<span class="number">0</span>;  <span class="comment">//到达汇合点的线程数</span></span><br><span class="line">mutex=Semaphore(<span class="number">1</span>);  <span class="comment">//保护count</span></span><br><span class="line">barrier = Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">P(mutex);</span><br><span class="line">count += <span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count == n) V(barrier);  <span class="comment">//唤醒一个</span></span><br><span class="line">P(barrier);  <span class="comment">//阻塞在这里</span></span><br><span class="line">V(barrier);  <span class="comment">//被唤醒的有责任唤醒下一个</span></span><br></pre></td></tr></table></figure>
<p><strong>信号量集</strong></p>
<p>需要访问多个资源s1，s2…</p>
<ul>
<li>AND型：一次性分配，一次性释放</li>
<li>一般：可以在AND机制上进行扩充，对于信号量Si，当其值低于ti时不予分配，并且可以需求占用di个。<code>SP(s1, t1, d1, ..., Sn, tn, dn)</code>和<code>SV(s1, d1, ..., sn, dn)</code></li>
</ul>
<h3 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h3><ol>
<li>管程的实现由编程语言负责，如java中的<code>synchronized()</code></li>
<li>为了区别等待的不同原因，引入条件变量。条件变量上可以做wait和signal操作。比如条件变量名为x，则x.wait()会把当前进程阻塞在x队列中，x.signal()会把x队列中一个进程唤醒</li>
<li>wait一定会阻塞当前进程。如果没等待进程signal会丢失</li>
</ol>
<p><strong>Hoarse管程</strong></p>
<ul>
<li>入口等待队列：尝试进入的等待</li>
<li>紧急等待队列：被唤醒但进不去</li>
</ul>
<p>信号量定义：</p>
<ul>
<li>管程用于互斥访问的信号量mutex（初值为1）。进程调用P，退出V。且wait操作也要V。</li>
<li>信号量next（初值为0），发出signal的进程需要p，直到被释放的进程退出管程或其他。进程退出管程前必须检查是否有别的进场在next上等待，若有则V。</li>
<li>信号量x-sem（初值为0），申请资源得不到满足时P，signal需要让x-sem等待进程立刻恢复。</li>
</ul>
<p><img src="/images/【OS】process/image-20240604102052946.png" alt="image-20240604102052946" style="zoom:50%;"></p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>低级通信：信号量、管程</p>
<p>高级通信：</p>
<ul>
<li>共享存储（最快）：线程天然共享进程空间（顺便提一嘴线程栈指针不共享）（Linux中线程是进程实现资源共享的一种方式）<ul>
<li>意义是同一块物理内存被映射到AB各自的进程地址空间</li>
<li>共享内存可以同时读但不能同时写，故需要同步机制约束（互斥锁或信号量）</li>
</ul>
</li>
<li>消息传递：由操作系统提供的发送信息和接受信息两个原语实现<ul>
<li>有阻塞调用和非阻塞调用方式。</li>
<li>操作系统空间中存在一组消息缓冲区。</li>
<li>需要解决消息丢失、延迟问题。以及编址问题。</li>
</ul>
</li>
<li>管道通信：管道也算一种文件，只能单向（若需要双向通信需要两个管道），且最多只能有一个进程进行读/写操作。依赖编译器。<ul>
<li>无名管道：单独构成独立的文件系统，只存在于内存中。只能是有亲缘关系之间创建。</li>
<li>有名管道：提供路径名，以FIFO的文件形式存在。<code>mkfifo()</code>创建。</li>
</ul>
</li>
</ul>
<p>信号量实现消息通信Send原语</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">buf-empty</span>=N;</span><br><span class="line"><span class="attribute">buf-full</span>=0;</span><br><span class="line"><span class="attribute">mutex1</span>=1;</span><br><span class="line"><span class="attribute">mutex2</span>=1;</span><br><span class="line"></span><br><span class="line">send(des, message) {</span><br><span class="line">根据des找接受进程；</span><br><span class="line">若未找到，出错返回；</span><br><span class="line"></span><br><span class="line">申请空缓冲区P(buf-empty);</span><br><span class="line">P(mutex1);</span><br><span class="line">取空缓冲区；</span><br><span class="line">V(mutex1);</span><br><span class="line"></span><br><span class="line">把消息从message复制到空缓冲区；</span><br><span class="line"></span><br><span class="line">P(mutex2);</span><br><span class="line">把消息缓冲区挂到接收进程消息队列；</span><br><span class="line">V(mutex2);</span><br><span class="line"></span><br><span class="line">V(buf-full);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="经典进程同步与互斥"><a href="#经典进程同步与互斥" class="headerlink" title="经典进程同步与互斥"></a>经典进程同步与互斥</h3><h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><ol>
<li>行为上，生产者之间互斥，消费者之间互斥，生产者和消费者同步互斥。</li>
<li>信号量，初始化设置互斥mutex=1，空闲数量empty=N，产品数量full=0</li>
<li>mutex需要放得近，否则可能全阻塞了。</li>
</ol>
<h4 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h4><ol>
<li>行为上，读者和读者共享Data，互斥访问readcount。读者写者以及写者写者都是互斥访问Data。</li>
<li>信号量，初始化正在读的进程数readcount=0，readcount互斥访问rmutex=1，Data互斥访问mutex=1。</li>
<li>读者先readcount互斥访问，如果之前没有读者则由他来P(mutex)，并rc++。读完后再rc互斥访问，rc—，如果已经没有其他读者了则由他来V(mutex)。</li>
<li>一般“信号量集”机制，mx表示允许写，初值为1，L表示允许读者数目，初值Rn。限制条件是读者最多Rn个。对写者，<code>SP(mx, 1, 1; L, Rn, 0)</code>写互斥所以是mx是1，1，并且只有在没有人正在读才能进去，所以L是Rn，0。<code>SV(mx, 1)</code>。对读者，<code>SP(L, 1, 1; mx, 1, 0)</code>同上，<code>SV(L, 1)</code>。</li>
<li>以上是读者有利。</li>
<li>读写公平的方法：新增信号量w，在读者写者都套一层PV，写者套在最外面，读者刚进入就可以P(w)，如果此时有写者在排队则不让继续进行，且读者刚进行完count的自增就可以V(w)了。</li>
</ol>
<h4 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h4><ol>
<li>死锁：所有人都无法进餐。饥饿：有人永远拿不到筷子。</li>
<li>破除互斥的解法：最多只允许四个人同时尝试进餐</li>
<li>破除循环等待的解法：筷子编号，哲学家按编号从低到高拿。或对哲学家编号，奇数人先拿左再拿右，偶数相反。</li>
<li>破除保持等待：同时拿起两根筷子或不拿起。</li>
</ol>
<p>以同时拿起为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore CS[<span class="number">5</span>]={<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1</span>};</span><br><span class="line">Semaphore mutex=<span class="number">1</span>;  <span class="comment">//取筷子信号量</span></span><br><span class="line"></span><br><span class="line">Pi() {</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(CS[i]);</span><br><span class="line">        P(CS[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        eat;</span><br><span class="line">        V(CS[i]);</span><br><span class="line">        V(CS[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        think;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>竞争资源导致死锁，资源包括：</p>
<ul>
<li>可剥夺资源：CPU、内存</li>
<li>非可剥夺资源：只能等进程用完后自行释放，如磁带机、打印机</li>
<li>临时性资源：一个进程产生被另一个进程使用，如消息、中断</li>
</ul>
<p><strong>死锁发生的四个必要条件</strong>：</p>
<ul>
<li>互斥</li>
<li>请求和保持：已经占有但还提出新的请求，而新的请求被别的进程占有，故一直不释放资源</li>
<li>不可剥夺：未使用完之前不能被剥夺</li>
<li>环路等待</li>
</ul>
<p><strong>活锁</strong></p>
<p>不被阻塞，但一直在重复尝试。可能自行解开。一种简单的方法是先来先服务。</p>
<p><strong>饥饿</strong></p>
<p>资源分配不均而长时间等待。拖到即使完成也没实际意义了就称进程饿死。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>不允许死锁发生<ul>
<li>预防（静态）：破坏死锁产生条件</li>
<li>避免（动态）：资源分配前判断</li>
</ul>
</li>
<li>允许死锁发生<ul>
<li>检测与解除</li>
<li>无所作为：鸵鸟算法</li>
</ul>
</li>
</ul>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>从四个必要条件出发</p>
<ul>
<li>互斥<ul>
<li>允许同时访问。一般很难实现。</li>
</ul>
</li>
<li>请求和保持<ul>
<li>只有系统能够满足才一次性全分配，否则不分配</li>
<li>动态执行则难以预测，且资源利用率低（只有占有所有资源才执行），降低并发</li>
</ul>
</li>
<li>不可剥夺<ul>
<li>已经占有资源，而新申请资源不能被满足，则需释放占有的全部资源。相当于强行剥夺。</li>
<li>实现困难，降低性能。</li>
</ul>
</li>
<li>环路等待<ul>
<li>资源有序分配。进程对资源的请求必须严格按照资源序号递增提出。</li>
<li>难以编号，增加系统开销。暂用不到的也要申请，故增加进程对资源占用时间。</li>
</ul>
</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>区别于预防，限制的不是很严格</p>
<ul>
<li>安全序列：若对于每一个进程Pi,它需要的资源可以被系统中当前可用资源加上所有进程Pj(j&lt;i)当前占有资源之和所满足，则{P1, P2 … Pn}为一个安全序列。</li>
<li>安全状态：系统存在一个进程执行序列</li>
<li>系统进入不安全状态也不一定死锁</li>
</ul>
<p>银行家算法：</p>
<p><img src="/images/【OS】process/image-20240603203722724.png" alt="image-20240603203722724"></p>
<p><img src="/images/【OS】process/image-20240603203735890.png" alt="image-20240603203735890"></p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><ol>
<li>一般是绘制资源分配图（RAG）判断。</li>
<li>有环路不一定死锁</li>
<li>资源分配图的化简方法：先满足请求，再释放（删边使其为孤立节点）</li>
<li>死锁定理：系统中某个时刻t为死锁状态的充要条件是<strong>t时刻系统的资源分配图是不可完全化简的。</strong></li>
</ol>
<p><img src="/images/【OS】process/image-20240603204656713.png" alt="image-20240603204656713" style="zoom: 67%;"></p>
<h4 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h4><p>一般有两种方法</p>
<ul>
<li><p>剥夺资源：使用挂起/激活挂起一些进程，剥夺它们的资源以解除死锁，待条件满足时，再激活进程。</p>
</li>
<li><p>撤消进程：使全部死锁的进程夭折掉；按照某种顺序逐个地撤消(回退)进程，直至有足够的资源可用，死锁状态消除为止。</p>
</li>
</ul>
<p>需要注意</p>
<ul>
<li>怎样保证不发生“饥饿”现象，如何保证并不总是剥夺同一进程的资源</li>
<li>“最小代价”，即最经济合算的算法，使得进程回退带来的开销最小。</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><strong>解决的问题</strong></p>
<ul>
<li>WHAT：进程调度算法</li>
<li>WHEN：进程调度时机<ul>
<li>只要OS取得CPU控制，进程切换就可能会发生</li>
<li>用户调用：程序显示请求（如打开文件）该进程可能会阻塞</li>
<li>陷进：指令出错导致当前进程终止</li>
<li>中断：外部因素影响</li>
</ul>
</li>
<li>HOW：CPU切换过程<ul>
<li>保存处理器上下文，包括PC和其他寄存器</li>
<li>更新当前进程的PCB</li>
<li>把进程移到合适的队列</li>
<li>选择另一个进程，切换PCB</li>
<li>重新装入CPU上下文</li>
</ul>
</li>
</ul>
<p><strong>调度类型</strong></p>
<ul>
<li>高级调度：作业调度，用户角度作业调度</li>
<li>中级调度：内外存交换，存储器资源管理</li>
<li>低级调度：进程或线程调度，CPU资源管理</li>
</ul>
<p>性能参数</p>
<ul>
<li>周转时间：作业提交到完成经历的时间（批处理）</li>
<li>响应时间：用户输入请求到系统首次给出相应的时间（分时系统）</li>
<li>截止时间：开始截止和完成截止（实时系统）</li>
<li>优先级<ul>
<li>静态、动态</li>
<li>一种方式是创建进程后给一个优先级，按照优先级排队；另一种方式是进程创建后优先级相同，随着运行降低优先级</li>
</ul>
</li>
<li>公平性<ul>
<li>不可抢占：只有在自己进入阻塞或者时间片用完才让出</li>
<li>抢占式：就绪队列中有优先级高于当前进程的立刻调度</li>
</ul>
</li>
<li>吞吐量：单位时间内完成的作业数（批处理）。平均周转时间不是吞吐量的倒数，因为并发的作业在时间上可以重叠</li>
<li>处理机利用率：（大中型主机）</li>
</ul>
<h3 id="批处理系统调度算法"><a href="#批处理系统调度算法" class="headerlink" title="批处理系统调度算法"></a>批处理系统调度算法</h3><p><img src="/images/【OS】process/image-20240604120054557.png" alt="image-20240604120054557" style="zoom:67%;"></p>
<ul>
<li>先来先服务FCFS：非抢占，利于长作业和CPU繁忙的作业</li>
<li>最短作业优先SJF：非抢占，提高吞吐量，缩减等待时间，不利于长作业</li>
<li>最短剩余时间优先SRTN：SJF改进为抢占式</li>
<li>最高响应比优先HRRN：非抢占式，选择响应比最大的投入运行<ul>
<li>RP=（作业已等待时间+作业服务时间）/作业服务时间</li>
<li>短作业容易得到较高响应比，长作业等足够久后也能得到高响应比</li>
</ul>
</li>
</ul>
<h3 id="交互式系统调度算法"><a href="#交互式系统调度算法" class="headerlink" title="交互式系统调度算法"></a>交互式系统调度算法</h3><ul>
<li>时间片轮转RR<ul>
<li>若是FIFO，时间片过长退化成FCFS，过短则上下文切换频繁，响应时间长</li>
<li>若是优先级算法，则又分为抢占式和非抢占式，静态优先级和动态优先级。</li>
</ul>
</li>
<li>多级队列MQ<ul>
<li>不同队列可有不同的优先级、时间片长度、调度策略等；在运行过程中还可改变进程所在队列。如：系统进程、用户交互进程、批处理进程等。</li>
</ul>
</li>
<li>多级反馈队列MFQ<ul>
<li>不必估计进程的执行时间，动态调节</li>
<li>规定优先级越低则时间片越长</li>
<li>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。</li>
<li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。</li>
</ul>
</li>
</ul>
<p><strong>优先级倒置现象</strong></p>
<p>A和C共享临界资源，A由于C被阻塞，再因为B的存在延长了被阻塞的时间</p>
<p>解决方案：</p>
<ul>
<li>优先级置顶：C在临界区中具有最高优先级，不允许被抢占</li>
<li>优先级进程：C在临界区中优先级与A相同</li>
</ul>
<h3 id="实时系统的调度算法"><a href="#实时系统的调度算法" class="headerlink" title="实时系统的调度算法"></a>实时系统的调度算法</h3><p>前提条件：</p>
<ul>
<li>任务集已知</li>
<li>任务是周期性的，运行独立的，运行时间不变的</li>
</ul>
<h4 id="静态表调度"><a href="#静态表调度" class="headerlink" title="静态表调度"></a>静态表调度</h4><ul>
<li>事先确定一个固定的调度方案</li>
<li>无任何计算，按固定方案进行，开销最小。无灵活性。</li>
</ul>
<h4 id="单调速率调度RMS"><a href="#单调速率调度RMS" class="headerlink" title="单调速率调度RMS"></a>单调速率调度RMS</h4><ul>
<li>任务周期越小，优先级越高</li>
<li>如果优先级相同则随机选择一个</li>
<li>RMS是静态最优调度算法</li>
<li>会出现失效的情况，即在下一个周期开始后上一个周期的任务还未被执行</li>
</ul>
<h4 id="最早截止期优先EDF"><a href="#最早截止期优先EDF" class="headerlink" title="最早截止期优先EDF"></a>最早截止期优先EDF</h4><ul>
<li>任务的绝对截止时间越早，优先级越高</li>
</ul>
<h4 id="最低松弛度优先算法LLF"><a href="#最低松弛度优先算法LLF" class="headerlink" title="最低松弛度优先算法LLF"></a>最低松弛度优先算法LLF</h4><ul>
<li>松弛度Laxity=任务截止时间-本身剩余运行时间-当前时间</li>
<li>调度时机：有进程执行完或有进程的Laxity=0</li>
</ul>
<h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3><ul>
<li>非对称式多处理系统AMP：主一从处理机系统，由主处理机管理一个公共就绪队列，并分派进程给从处理机执行。</li>
<li><p>对称式多处理系统SMP：多处理器系统中，各个处理器的地位相同。</p>
<ul>
<li>集中控制：静态、动态</li>
<li>分散控制：自调度</li>
</ul>
</li>
<li><p>静态分配：每个CPU设立一个就绪队列，进程从开始执行到完成，都<strong>在同一个CPU上</strong>。</p>
</li>
<li>动态分配：各个CPU采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均。</li>
<li>自调度：所有CPU采用一个公共就绪队列，每个处理机都可以从队列中选择适当进程来执行。需要对就绪队列的数据结构进行<strong>互斥访问控制</strong>。最常用的算法，实现时易于移植，采用单处理机的调度技术。<ul>
<li>不需要专门的处理机从事任务分派工作</li>
<li>当处理机个数较多(如十几个或上百个)时，对就绪队列的访问可能成为系统的瓶颈</li>
<li>低效、线程切换</li>
</ul>
</li>
<li><p>成组调度：将一个进程中的一组线程，每次同时分派到一组处理机上执行，在剥夺处理机时也同时对这一组线程进行。</p>
<ul>
<li>提高了这些线程的执行并行度，有利于减少阻塞和加快推进速度，最终提高系统吞吐量。</li>
<li>系统内线程总数相同时能够减少调度次数，从而减少调度算法的开销。</li>
<li>面向程序平分（两个进程各占一半时间）、面向线程平分（进程线程多的占更多时间，闲置的CPU时间也就变少了）</li>
</ul>
</li>
<li><p>专用处理机调度：为进程中的每个线程都固定分配一个CPU,直到该线程执行完成。适用于CPU数量众多的高度并行系统。</p>
<ul>
<li>线程执行时不需切换，相应的开销可以大大减小，推进速度更快。</li>
<li>线程阻塞时，造成CPU的闲置。</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Carbon
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2024/06/02/%E3%80%90OS%E3%80%91process/" title="【OS】process">http://example.com/2024/06/02/【OS】process/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/05/27/%E3%80%90OS%E3%80%91file/" rel="prev" title="【OS】file">
                  <i class="fa fa-angle-left"></i> 【OS】file
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/06/05/%E3%80%90OS%E3%80%91backup/" rel="next" title="【OS】backup">
                  【OS】backup <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Carbon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
